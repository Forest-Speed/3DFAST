'''
Reconstruct optical sectioning SIM data generated by SIMscope3D

Douglas Shepherd
douglas.shepherd@asu.edu

Based on doi: 10.1364/OL.22.001905 and doi: 10.1364/BOE.422703

2022.01.25
'''

from pathlib import Path
import numpy as np
import tifffile
from skimage.exposure import match_histograms, rescale_intensity
from skimage.restoration import calibrate_denoiser, denoise_tv_chambolle
import matplotlib.pyplot as plt
from tqdm import tqdm

input_file_path = Path("SIM_Stack_3_1.tif")
root_path = input_file_path.parents[0]
img = tifffile.imread(input_file_path)
#imarray = np.array(img)
I1 = img[0,:]
I2 = img[1,:]
I3 = img[2,:]

#DANDAN
#os_image = 0.5 * np.sqrt((2*I2 - I1 - I3)**2 + (I3 - I1)**2)

# NEIL
#os_image = np.sqrt(((I1-I2)**2)+((I1-I3)**2)+((I2-I3)**2))

#os_sim = rescale_intensity(os_image,out_range=(0,255)).astype(np.uint8)
#plt.imshow(os_image)



#tifffile.imwrite('SIM_Stack_3_1.tif', os_image)



def optical_sectioning_sim_90deg(imgs):
    '''
    Calculate optically sectioned image for 90 degree phase shifts.
    The image is formed as: I = I0 + Ic*cos(phi) + Is*sin(phi)
    Need to recover Ip = sqrt(Ic^2+Is^2) to get only intensity that are modulated (in-focus)
    I1 = I0+Ic <- phi = 0
    I2 = I0+Is <- phi = 90
    I3 = I0-Ic <- phi = 180
    For (0,90,180) we use: 0.5 * sqrt( (2I2-I1-I3)^2 + (I3-I1)^2) = sqrt((Ic^2+Is^2)) = Ip 

    Parameters
    ----------
    imgs : ndarray
        array of images. Assumes that phase is axis = 0.

    Returns
    -------
    os_image: ndarray
        optically sectioned image
    '''

    # separate 0, 90, 180 images
    I1 = imgs[0,:]
    I2 = imgs[1,:]
    I3 = imgs[2,:]

    # calculate OS image using law of sines to recover in-focus intensities
    os_image = 0.5 * np.sqrt((2*I2 - I1 - I3)**2 + (I3 - I1)**2)

    return os_image

def match_histogram_z(imgs,nangles,nphases):
    '''
    Match histograms for all angles and phases at a z plane

    Parameters
    ----------
    imgs : ndarray
        array of images. Assumes that angle is axis = 0 and phase is axis = 0.
    nangles: int
        number of angles in data
    nphases: int
        number of phases in data

    Returns
    -------
    os_image: ndarray
        array of images with matched histograms.
    '''

    for ii in range(nangles):
            for jj in range(1, nphases):
                imgs[ii, jj,:] = match_histograms(imgs[ii, jj,:], imgs[ii, 0,:])

    return imgs

# experimental parameters (not used right now)
dx = 1.0
dz = 1.0
excitation_wl = 0.470
emission_wl = 0.520
na = 0.3
nangles = 3
nphases = 3

# load the data and reshape
#input_file_path = Path("c://data//Zstack_33per_60min//SH_10_MMStack_Pos-0-resave.tif")
input_file_path = Path("SIM.tif")
root_path = input_file_path.parents[0]
img = tifffile.imread(input_file_path)

# TO DO: correctly parse metadata / load multiple images loop over timelapse
nt = 1
nz = int(img.shape[0]/(nangles*nphases))
ny = img.shape[1]
nx = img.shape[2]
img_reshape = np.reshape(img,[nz,nangles,nphases,ny,nx])

# turn image into float
img_reshape = img_reshape.astype(np.float32)

# create storage variables
widefield = np.zeros((nz,ny,nx),dtype=np.float32)
os_sim_per_angle = np.zeros((nangles,ny,nx),dtype=np.float32)
os_sim_angle = np.zeros((nangles,nz,ny,nx),dtype=np.float32)
os_sim = np.zeros((nz,ny,nx),dtype=np.float32)




# loop over all timepoints
for t_idx in tqdm(range(0,nt),desc='time',leave=True):

    # check if there is more than one time point
    if nt==1:
        imgs_to_process = img_reshape[:]
    else:
        imgs_to_process = img_reshape[t_idx,:]
    
    for z_idx in tqdm(range(0,nz),desc='SIM OS per z plane',leave=False):
        
        # match histograms for each phase & angle at this z plane
        matched_imgs = match_histogram_z(imgs_to_process[z_idx,:],nangles,nphases)

        # calculate widefield image at this z plane
        widefield[z_idx,:] = np.nanmean(matched_imgs, axis=(0, 1))
        
        # calculate os-sim image for each angle at this z plane
        for angle_idx in range(0,nangles):
            os_sim_per_angle[angle_idx,:]=optical_sectioning_sim_90deg(matched_imgs[angle_idx,:])
            os_sim_angle[angle_idx,z_idx,:]=os_sim_per_angle[angle_idx,:]
        # average os-sim over all angles at this z plane
        os_sim[z_idx,:] = np.nanmean(os_sim_per_angle,axis=0)

    # find stack with large mean value (proxy for brightness) in os-sim image
    brightness = np.zeros(nz)
    for z_idx in range(0,nz):
        brightness[z_idx] = np.nanmean(os_sim[z_idx,:])
    z_idx_brightest_frame = np.argmax(brightness)

    # match histograms to correct for axial attenuation
    for z_idx in tqdm(range(0,nz),desc='histogram match',leave=False):
        widefield[z_idx,:] = match_histograms(widefield[z_idx,:],widefield[z_idx_brightest_frame,:])
        os_sim[z_idx,:] = match_histograms(os_sim[z_idx,:],os_sim[z_idx_brightest_frame,:])
        for angle_idx in range(0,nangles):
            os_sim_angle[angle_idx,z_idx,:]=match_histograms(os_sim_angle[angle_idx,z_idx,:],
                                                            os_sim_angle[angle_idx,z_idx_brightest_frame,:])

    if t_idx == 0:
        # calibrate TV denoiser on a subset of the data around the frame with highest mean value 
        # see https://bit.ly/3tEx7it for a full tutorial on invariant calibration of denoisers
        parameter_ranges_tv = {'weight': np.arange(0.01, .3, 0.02)}
        calibrated_denoiser = calibrate_denoiser(os_sim[z_idx_brightest_frame-10:z_idx_brightest_frame+10,:],
                                                denoise_tv_chambolle,
                                                denoise_parameters=parameter_ranges_tv)

    # denoise the full stack using calibrated TV denoiser
    os_sim_denoised = calibrated_denoiser(os_sim)

    # rescale to 8-bit for output
    widefield = rescale_intensity(widefield,out_range=(0,255)).astype(np.uint8)
    os_sim = rescale_intensity(os_sim,out_range=(0,255)).astype(np.uint8)
    os_sim_denoised = rescale_intensity(os_sim_denoised,out_range=(0,255)).astype(np.uint8)
    os_sim_angle = rescale_intensity(os_sim_angle,out_range=(0,255)).astype(np.uint8)

    # write outputs with metadata
    output_file_path_widefield = Path(root_path / Path('widefield_t'+str(t_idx).zfill(3)+'.tif'))
    tifffile.imwrite(file=output_file_path_widefield,
                    data=widefield,
                    imagej=True, 
                    resolution=(1./dx, 1./dx),
                    metadata={'spacing': dz, 'unit': 'um', 'axes': 'ZYX'})

    output_file_path_os_sim = Path(root_path / Path('os_sim_t'+str(t_idx).zfill(3)+'.tif'))
    tifffile.imwrite(file=output_file_path_os_sim,
                    data=os_sim,
                    imagej=True, 
                    resolution=(1./dx, 1./dx),
                    metadata={'spacing': dz, 'unit': 'um', 'axes': 'ZYX'})

    output_file_path_os_sim_denoised = Path(root_path / Path('os_sim_denoised_t'+str(t_idx).zfill(3)+'.tif'))
    tifffile.imwrite(file=output_file_path_os_sim_denoised,
                    data=os_sim_denoised,
                    imagej=True, 
                    resolution=(1./dx, 1./dx),
                    metadata={'spacing': dz, 'unit': 'um', 'axes': 'ZYX'})
